// Generates a rolltable based on a compendium

// CONFIGURATION
// - collection: the identifier of the collection (tip: put something wrong to get the available list in the console F12)
// - filters: a list of filters to apply on the collection
// 
const CONFIG = {
  collection: "pf2e.spells-srd", 
  filters: { "data.data.level.value": "1" },
}

// SCRIPT
// Do NOT change unless you know what you're doing!

const pack = game.packs.get(CONFIG.collection);

if(!pack) {
  ui.notifications.error(`Collection '${CONFIG.collection}' couldn't be found! Please check console (F12).`)
  let list = []
  game.packs.entries.forEach( p => list.push(p.collection) );
  console.log(`Collection '${CONFIG.collection}' couldn't be found! Available collections:`)
  console.log(list)
}

else {
  console.log(pack)
  ui.notifications.info(`Process started. Please wait! Might take several seconds!`)
  getFilteredItems(pack, CONFIG.filters).then( async function(items) {
    let rt = await RollTable.create({
      name: `Rolltable for ${pack.title}`, 
      description: "Automatically generated by macro",
      formula: `1d${items.length}`
    })
    let results = []
    let i = 1
    items.forEach( item => {
      results.push({ 
        type: 2, 
        text: item.name, 
        img: item.img,
        collection: CONFIG.collection,
        resultId: item._id,
        weight: 1,
        drawn: false,
        range: [i, i]
      })
      i++
    })
    await rt.createEmbeddedEntity("TableResult", results)
    ui.notifications.info(`RollTable successfully generated!`)
  })
}

//
// This function returns the list of elements from pack 
// matching the provided filters
//
async function getFilteredItems(pack, filters) {
  let filtered = [];  
  const index = await pack.getIndex()
  for(let i=0; i<index.length; i++) {
    const entity = await pack.getEntity(index[i]._id)
    const fKeys = Object.keys(filters)
    let ok = true
    // apply filters
    for(let f=0; f<fKeys.length; f++) {
      if(hasProperty(entity, fKeys[f]) && getProperty(entity, fKeys[f]) != filters[fKeys[f]]) {
        ok = false
        break
      }
    }
    if( ok ) filtered.push(entity)
  }
  return filtered
}
